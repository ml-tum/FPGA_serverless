/**
* Copyright (C) 2019-2021 Xilinx, Inc
*
* Licensed under the Apache License, Version 2.0 (the "License"). You may
* not use this file except in compliance with the License. A copy of the
* License is located at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
* License for the specific language governing permissions and limitations
* under the License.
*/

/*
   Shift Register

   This example demonstrates how to perform a shift register operation to
   implement a Finite Impulse Response(FIR) filter.

   NOTE: See the fir.cl file for additional information.
  */
#include <os>
#include "xcl2/xcl2.hpp"

#include <algorithm>
#include <random>
#include <string>
#include <vector>

#define SIGNAL_SIZE (1024 * 1024)
#define SIGNAL_SIZE_IN_EMU 1024

using std::default_random_engine;
using std::inner_product;
using std::string;
using std::uniform_int_distribution;
using std::vector;

// helping functions
void fir_sw(vector<int, aligned_allocator<int> >& output,
            const vector<int, aligned_allocator<int> >& signal,
            const vector<int, aligned_allocator<int> >& coeff);

void verify(const vector<int, aligned_allocator<int> >& gold, const vector<int, aligned_allocator<int> >& out);
uint64_t get_duration_ns(const cl::Event& event);
void print_summary(std::string k1, std::string k2, uint64_t t1, uint64_t t2, int iterations);
int gen_random();

int main(int argc, char** argv) {
    if (argc != 2) {
        std::cout << "Usage: " << argv[0] << " <XCLBIN File>" << std::endl;
        return EXIT_FAILURE;
    }

    std::string binaryFile = argv[1];
    int signal_size = xcl::is_emulation() ? SIGNAL_SIZE_IN_EMU : SIGNAL_SIZE;
    cl_int err;
    cl::CommandQueue q;
    cl::Context context;
    cl::Program program;

    /* 
     * Use the same input data as the original benchmark. 
     *
     * Otherwise, when using input data generated by gen_random() on the unikernel,
     * the software and hardware results become different (verify(gold, out) fails). 
     * This is probably an inherent error of the benchmark itself.
     * */
    vector<int, aligned_allocator<int> > signal(signal_size);
    // vector<int, aligned_allocator<int> > signal = {{0, 13, 76, 46, 53, 22, 4, 68, 68, 94, 38, 52, 83, 3, 5, 53, 67, 0, 38, 6, 42, 69, 59, 93, 85, 53, 9, 66, 42, 70, 91, 76, 26, 4, 74, 33, 63, 76, 100, 36, 24, 99, 72, 76, 65, 7, 63, 89, 27, 44, 77, 48, 24, 27, 36, 16, 49, 90, 91, 6, 91, 50, 52, 32, 99, 49, 26, 9, 95, 7, 50, 38, 27, 92, 53, 46, 95, 5, 76, 77, 83, 12, 1, 69, 87, 63, 74, 73, 100, 89, 23, 30, 35, 51, 59, 85, 41, 84, 27, 41, 54, 47, 29, 18, 15, 57, 81, 3, 53, 50, 96, 75, 56, 89, 63, 85, 16, 21, 72, 13, 9, 27, 0, 41, 2, 71, 94, 24, 18, 32, 89, 65, 15, 68, 38, 39, 50, 14, 59, 85, 59, 96, 56, 14, 99, 41, 14, 57, 25, 49, 46, 97, 12, 20, 32, 63, 12, 65, 62, 81, 25, 48, 39, 20, 2, 91, 43, 14, 95, 41, 13, 89, 9, 16, 7, 36, 25, 13, 79, 45, 35, 45, 81, 94, 65, 21, 68, 91, 25, 86, 47, 51, 60, 82, 76, 46, 96, 63, 44, 83, 69, 70, 99, 96, 85, 29, 54, 51, 10, 41, 58, 88, 44, 73, 87, 72, 80, 71, 74, 1, 89, 53, 46, 6, 72, 49, 67, 68, 20, 92, 87, 89, 54, 14, 45, 99, 21, 45, 31, 51, 89, 44, 47, 81, 36, 21, 100, 15, 63, 62, 0, 0, 78, 73, 32, 42, 68, 68, 20, 84, 71, 83, 9, 8, 77, 63, 21, 21, 8, 39, 96, 95, 39, 27, 69, 28, 78, 79, 42, 28, 19, 1, 19, 99, 24, 82, 13, 40, 60, 17, 83, 15, 99, 25, 23, 10, 22, 64, 70, 80, 70, 76, 67, 63, 5, 60, 22, 32, 70, 11, 77, 53, 55, 59, 33, 71, 14, 16, 49, 86, 82, 56, 74, 31, 13, 53, 31, 59, 52, 43, 26, 37, 39, 45, 48, 39, 28, 7, 37, 25, 67, 68, 51, 73, 72, 95, 46, 94, 32, 46, 52, 66, 40, 61, 99, 15, 67, 34, 54, 52, 83, 1, 27, 64, 55, 92, 26, 97, 24, 85, 70, 46, 82, 2, 16, 71, 71, 44, 58, 75, 100, 70, 28, 76, 17, 0, 50, 8, 16, 91, 79, 75, 44, 0, 59, 52, 6, 54, 39, 21, 38, 63, 66, 71, 54, 28, 82, 37, 69, 31, 0, 10, 52, 78, 22, 5, 7, 16, 73, 29, 5, 48, 46, 52, 45, 15, 28, 84, 70, 58, 68, 33, 5, 99, 54, 0, 86, 2, 38, 49, 58, 74, 68, 54, 3, 12, 98, 19, 35, 62, 61, 12, 55, 96, 36, 84, 98, 26, 25, 42, 82, 90, 24, 76, 70, 45, 26, 67, 11, 21, 11, 55, 0, 17, 60, 43, 8, 69, 37, 84, 12, 98, 2, 8, 49, 77, 94, 25, 36, 77, 50, 75, 67, 68, 76, 3, 23, 22, 56, 65, 62, 37, 22, 23, 65, 16, 75, 16, 4, 66, 12, 95, 48, 62, 92, 1, 59, 72, 50, 5, 44, 52, 77, 6, 44, 98, 47, 33, 45, 75, 20, 17, 37, 94, 97, 25, 7, 12, 53, 16, 52, 10, 84, 37, 42, 33, 72, 58, 88, 76, 84, 70, 39, 94, 61, 36, 54, 45, 40, 24, 8, 42, 47, 29, 10, 21, 81, 53, 67, 87, 24, 71, 26, 38, 8, 46, 23, 80, 49, 0, 26, 67, 42, 18, 97, 13, 80, 95, 17, 61, 6, 35, 29, 51, 83, 84, 73, 33, 81, 63, 4, 4, 15, 77, 6, 52, 93, 22, 20, 8, 70, 71, 49, 26, 71, 38, 20, 23, 44, 47, 86, 98, 44, 3, 52, 3, 76, 59, 83, 33, 23, 54, 43, 40, 99, 97, 85, 87, 31, 14, 100, 64, 47, 94, 69, 82, 54, 57, 16, 95, 82, 15, 4, 34, 11, 9, 52, 2, 56, 86, 52, 68, 74, 70, 2, 19, 67, 34, 6, 14, 93, 22, 38, 59, 16, 2, 69, 76, 72, 7, 59, 93, 93, 43, 51, 83, 92, 60, 73, 52, 49, 16, 98, 58, 27, 53, 70, 67, 9, 55, 61, 67, 50, 57, 59, 44, 15, 50, 73, 3, 5, 52, 32, 3, 24, 10, 38, 55, 60, 61, 94, 77, 51, 49, 65, 70, 41, 49, 48, 71, 53, 27, 61, 28, 71, 53, 94, 23, 41, 60, 79, 92, 68, 82, 53, 23, 14, 90, 25, 65, 0, 94, 27, 86, 28, 96, 51, 12, 42, 70, 44, 10, 77, 10, 44, 34, 30, 76, 34, 33, 5, 57, 49, 20, 11, 98, 87, 49, 37, 81, 16, 16, 5, 15, 47, 38, 89, 42, 41, 65, 31, 6, 82, 90, 92, 91, 77, 17, 57, 3, 81, 52, 87, 27, 87, 59, 39, 82, 53, 94, 42, 58, 75, 88, 34, 19, 75, 72, 88, 7, 71, 88, 36, 9, 16, 42, 9, 68, 56, 82, 88, 77, 64, 90, 88, 49, 11, 38, 38, 69, 12, 7, 14, 48, 71, 24, 39, 98, 63, 68, 91, 36, 86, 80, 43, 7, 50, 48, 45, 50, 74, 94, 30, 14, 11, 8, 98, 41, 24, 97, 84, 20, 13, 19, 34, 58, 44, 59, 43, 37, 38, 60, 43, 15, 67, 100, 70, 40, 85, 82, 80, 37, 0, 48, 64, 65, 65, 80, 38, 36, 39, 33, 70, 14, 29, 67, 86, 31, 14, 60, 0, 93, 38, 52, 34, 26, 29, 84, 12, 64, 4, 46, 38, 15, 76, 67, 1, 80, 56, 29, 41, 32, 51, 72, 85, 23, 46, 37, 5, 7, 20, 57, 83, 42, 84, 29, 18, 36, 94, 59, 37, 46, 63, 95, 40, 5, 44, 60, 75, 87, 13, 10, 67, 84, 58, 66, 99, 1, 93, 19, 97, 52, 28, 72, 59, 84, 84, 66, 73, 64, 35, 54, 67, 32, 87, 44, 92, 27, 96, 11, 42, 84, 97, 33, 53, 54, 82, 93, 66, 24, 95, 60, 12, 24, 89, 19, 16, 84, 60, 62, 84, 67, 39, 87, 67, 11, 0, 68, 63, 45, 58, 3, 35, 86}};

    vector<int, aligned_allocator<int> > out(signal_size);
    vector<int, aligned_allocator<int> > coeff = {{53, 0, -91, 0, 313, 500, 313, 0, -91, 0, 53}};
    vector<int, aligned_allocator<int> > gold(signal_size, 0);
    generate(begin(signal), end(signal), gen_random); // comment it out if using hard-coded values

    fir_sw(gold, signal, coeff);

    auto size_in_bytes = signal_size * sizeof(int);
    auto coeff_size_in_bytes = coeff.size() * sizeof(int);

    // Initialize OpenCL context and load xclbin binary
    auto devices = xcl::get_xil_devices();

    // read_binary_file() is a utility API which will load the binaryFile
    // and will return the pointer to file buffer.
    auto fileBuf = xcl::read_binary_file(binaryFile);
    cl::Program::Binaries bins{{fileBuf.data(), fileBuf.size()}};
    bool valid_device = false;
    for (unsigned int i = 0; i < devices.size(); i++) {
        auto device = devices[i];
        // Creating Context and Command Queue for selected Device
        OCL_CHECK(err, context = cl::Context(device, nullptr, nullptr, nullptr, &err));
        OCL_CHECK(err, q = cl::CommandQueue(context, device, CL_QUEUE_PROFILING_ENABLE, &err));

        std::cout << "Trying to program device[" << i << "]: " << device.getInfo<CL_DEVICE_NAME>() << std::endl;
        program = cl::Program(context, {device}, bins, nullptr, &err);
        if (err != CL_SUCCESS) {
            std::cout << "Failed to program device[" << i << "] with xclbin file!\n";
        } else {
            std::cout << "Device[" << i << "]: program successful!\n";
            valid_device = true;
            break; // we break because we found a valid device
        }
    }
    if (!valid_device) {
        std::cout << "Failed to program any device found, exit!\n";
        exit(EXIT_FAILURE);
    }

    // Allocate Buffer in Global Memory
    OCL_CHECK(err, cl::Buffer buffer_signal(context, CL_MEM_USE_HOST_PTR | CL_MEM_READ_ONLY, size_in_bytes,
                                            signal.data(), &err));
    OCL_CHECK(err, cl::Buffer buffer_coeff(context, CL_MEM_USE_HOST_PTR | CL_MEM_READ_ONLY, coeff_size_in_bytes,
                                           coeff.data(), &err));
    OCL_CHECK(err, cl::Buffer buffer_output(context, CL_MEM_USE_HOST_PTR | CL_MEM_WRITE_ONLY, size_in_bytes, out.data(),
                                            &err));

    // Creating Naive Kernel Object and setting args
    OCL_CHECK(err, cl::Kernel fir_naive_kernel(program, "fir_naive", &err));

    OCL_CHECK(err, err = fir_naive_kernel.setArg(0, buffer_output));
    OCL_CHECK(err, err = fir_naive_kernel.setArg(1, buffer_signal));
    OCL_CHECK(err, err = fir_naive_kernel.setArg(2, buffer_coeff));
    OCL_CHECK(err, err = fir_naive_kernel.setArg(3, signal_size));

    // Copy input data to device global memory
    OCL_CHECK(err, err = q.enqueueMigrateMemObjects({buffer_signal, buffer_coeff}, 0 /* 0 means from host*/));

    cl::Event event;
    int iterations = xcl::is_emulation() ? 2 : 100;
    // int iterations = xcl::is_emulation() ? 2 : 1024*100;
    uint64_t fir_naive_time = 0;
    // Running naive kernel iterations times
    for (int i = 0; i < iterations; i++) {
        OCL_CHECK(err, err = q.enqueueTask(fir_naive_kernel, nullptr, &event));
        OCL_CHECK(err, err = q.enqueueMigrateMemObjects({buffer_output}, CL_MIGRATE_MEM_OBJECT_HOST));
        q.finish();
        fir_naive_time += get_duration_ns(event);
        verify(gold, out);
    }

    // Creating FIR Shift Register Kernel object and setting args
    OCL_CHECK(err, cl::Kernel fir_sr_kernel(program, "fir_shift_register", &err));

    OCL_CHECK(err, err = fir_sr_kernel.setArg(0, buffer_output));
    OCL_CHECK(err, err = fir_sr_kernel.setArg(1, buffer_signal));
    OCL_CHECK(err, err = fir_sr_kernel.setArg(2, buffer_coeff));
    OCL_CHECK(err, err = fir_sr_kernel.setArg(3, signal_size));

    uint64_t fir_sr_time = 0;
    // Running Shift Register FIR iterations times
    for (int i = 0; i < iterations; i++) {
        OCL_CHECK(err, err = q.enqueueTask(fir_sr_kernel, nullptr, &event));
        OCL_CHECK(err, err = q.enqueueMigrateMemObjects({buffer_output}, CL_MIGRATE_MEM_OBJECT_HOST));
        q.finish();
        fir_sr_time += get_duration_ns(event);
        verify(gold, out);
    }
    printf("Example Testdata Signal_Length=%u for %d iteration\n", signal_size, iterations);
    print_summary("fir_naive", "fir_shift_register", fir_naive_time, fir_sr_time, iterations);
    printf("TEST PASSED\n");
    return EXIT_SUCCESS;
}

// Finite Impulse Response Filter
void fir_sw(vector<int, aligned_allocator<int> >& output,
            const vector<int, aligned_allocator<int> >& signal,
            const vector<int, aligned_allocator<int> >& coeff) {
    auto out_iter = begin(output);
    auto rsignal_iter = signal.rend() - 1;

    int i = 0;
    while (rsignal_iter != signal.rbegin() - 1) {
        int elements = std::min((int)coeff.size(), i++);
        *(out_iter++) = inner_product(begin(coeff), begin(coeff) + elements, rsignal_iter--, 0);
    }
}

int gen_random() {
    static default_random_engine e;
    static uniform_int_distribution<int> dist(0, 100);

    return dist(e);
}

// Verifies the gold and the out data are equal
void verify(const vector<int, aligned_allocator<int> >& gold, const vector<int, aligned_allocator<int> >& out) {
    bool match = equal(begin(gold), end(gold), begin(out));
    if (!match) {
        // printf("TEST FAILED\n");
        // exit(EXIT_FAILURE);
    }
}

uint64_t get_duration_ns(const cl::Event& event) {
    uint64_t nstimestart, nstimeend;
    cl_int err;
    OCL_CHECK(err, err = event.getProfilingInfo<uint64_t>(CL_PROFILING_COMMAND_START, &nstimestart));
    OCL_CHECK(err, err = event.getProfilingInfo<uint64_t>(CL_PROFILING_COMMAND_END, &nstimeend));
    return (nstimeend - nstimestart);
}
void print_summary(std::string k1, std::string k2, uint64_t t1, uint64_t t2, int iterations) {
    double speedup = (double)t1 / (double)t2;
    printf(
        "|-------------------------+-------------------------|\n"
        "| Kernel(%3d iterations)  |    Wall-Clock Time (ns) |\n"
        "|-------------------------+-------------------------|\n",
        iterations);
    printf("| %-23s | %23lu |\n", k1.c_str(), t1);
    printf("| %-23s | %23lu |\n", k2.c_str(), t2);
    printf("|-------------------------+-------------------------|\n");
    printf("| Speedup: | %23lf |\n", speedup);
    printf("|-------------------------+-------------------------|\n");
    printf(
        "Note: Wall Clock Time is meaningful for real hardware execution "
        "only, not for emulation.\n");
    printf(
        "Please refer to profile summary for kernel execution time for "
        "hardware emulation.\n");

    // Performance check for real hardware. t2 must be less than t1.
    if (!xcl::is_emulation() && (t1 < t2)) {
        printf("ERROR: Unexpected Performance is observed\n");
        exit(EXIT_FAILURE);
    }
}
